#!/usr/bin/env python3 
# coding: utf-8 

# **********************************************************************************************************************
#  Copyright 2023 Vikky Masih, MFS-DSAI, IIT Guwahati, India.
#  License: Simplified BSD License
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
# disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
# following disclaimer in the documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# **********************************************************************************************************************

import os
import re
import shutil
import subprocess
import json

# 20% penalty if a testcase is failed if number of testcases is greater than 1/PENALTY
PENALTY = 0.20
# Score considered as a good score for positive feedback.
GOOD_SCORE = 0.8
# Command execution timeouts in seconds.
BUILD_TIMEOUT = 10
RUN_TIMEOUT = 10
# Executable name generated by running the build command
BUILT_EXECUTABLE_NAME = 'testApp'
# Absolute location of the parent directory of this script. (Coursera runs the script from root directory)
GRADER_DIR = "/grader"
# Punctuation symbols to be removed for better matching
PUNCTUATIONS = ",;:?"


# As per Coursera documentation
def send_feedback(score, message):
    post = {'fractionalScore': score, 'feedback': message}
    print(json.dumps(post))
    with open("/shared/feedback.json", "w") as outfile:
        json.dump(post, outfile)


# Remove fullstop (exclude decimal point)
def remove_fullstops(a):
    a = a + " "
    for k in re.compile(r"\.\D").finditer(a):
        loc = k.span()[0]
        a = a[:loc] + " " + a[loc + 1:]
    return a


# Remove specified punctuations from a string
def remove_punctuations(a, pun=PUNCTUATIONS):
    for k in pun:
        a = a.replace(k, " ")
    return remove_fullstops(a)


# Two text is considered equal if it has same lower-cased token sequence with specific punctuations removed.
def text_mismatch(a, b):
    p = " ".join(remove_punctuations(a).lower().split())
    q = " ".join(remove_punctuations(b).lower().split())
    return p != q


# Return difference in tokens as a message for hint
def diff_message(a, b):
    # Remove specific punctuations
    a = remove_punctuations(a)
    b = remove_punctuations(b)

    # Get lower-cased tokens
    a_tokens = a.lower().split()
    b_tokens = b.lower().split()
    extra = a_tokens.copy()
    missing = b_tokens.copy()

    # Find extra and missing tokens
    for k in b_tokens:
        try:
            extra.remove(k)
        except ValueError:
            pass
    for k in a_tokens:
        try:
            missing.remove(k)
        except ValueError:
            pass

    # Convert back to original-cased tokens
    extra = [a.split()[a_tokens.index(x)] for x in extra]
    missing = [b.split()[b_tokens.index(x)] for x in missing]
    return f"Extra tokens = {extra}\r\n" + f"Missing tokens = {missing}\r\n"


def main(coursera_part_id):
    # All direct writes to stdout can be seen as logs on Coursera only by the instructor.
    print(f"Penalty = {PENALTY} per failed testcase")
    print(f"Build Timeout = {BUILD_TIMEOUT}s")
    print(f"Run Timeout = {RUN_TIMEOUT}s")
    print(f"Executable Name = {BUILT_EXECUTABLE_NAME}")
    print('-' * 80)

    # Searching and sorting all programming assignment parts
    parts = [x for x in os.listdir(GRADER_DIR) if
             (os.path.isdir(os.path.join(GRADER_DIR, x)) and x.lower().startswith('part_'))]
    parts.sort()
    print(f"Parts={parts}")

    # When no programming assignment parts are found
    if len(parts) == 0:
        message = "Folders Missing (Admin Configuration Error)"
        print(message)
        send_feedback(0.0, message)
        return

    # Searching for and using the programming assignment part matching with coursera_part_id.
    # Then extracting the build commands and submission filename.
    part_folder = None
    part_build = None
    part_submit = None
    for k in parts:
        with open(os.path.join(GRADER_DIR, k, 'Coursera_PartID.txt'), "r") as f:
            pid = f.read().strip()
        if pid == coursera_part_id:
            part_folder = os.path.join(GRADER_DIR, k)
            with open(os.path.join(part_folder, 'Build_Command.txt'), "r") as f:
                part_build = f.read().strip()
            with open(os.path.join(part_folder, 'Submission_Filename.txt'), "r") as f:
                part_submit = f.read().strip()
    # When none of the programming assignment parts matches with coursera_part_id
    if not part_folder:
        message = "Coursera partId mismatch (Admin Configuration Error)"
        print(message)
        send_feedback(0.0, message)
        return
    # When submission filename is empty string
    if len(part_submit) == 0:
        message = "Submission file not specified (Admin Configuration Error)"
        send_feedback(0.0, message)
        return

    # Copying submission file to build directory.
    file_loc = os.path.join(os.path.sep, "shared", "submission", part_submit)
    if not os.path.isfile(file_loc):
        message = "Submission file not found"
        send_feedback(0.0, message)
        return
    else:
        build_dir = os.path.join(part_folder, "build_directory")
        shutil.copyfile(file_loc, os.path.join(build_dir, part_submit))

    # Extracting submission file if it is an archive
    archive_types = [x[0].lower() for x in shutil.get_archive_formats()]
    file_extension = os.path.splitext(part_submit)[1].removeprefix('.').lower()
    if file_extension in archive_types:
        print("Archive Found: Extracting")
        try:
            shutil.unpack_archive(os.path.join(build_dir, part_submit), build_dir)
        except Exception as e:
            message = "ERROR: Archive extraction failed. " + str(e)
            send_feedback(0.0, message)
            return

    # Building the program using user supplied command
    print("Building...")
    try:
        ret = subprocess.run([part_build],
                             cwd=build_dir,
                             shell=True,
                             check=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             timeout=BUILD_TIMEOUT)
    except subprocess.CalledProcessError as e:
        message = "Building failed. " + str(e)
        print(message)
        print(e.stdout.decode('utf-8'))
        print(e.stderr.decode('utf-8'))
        send_feedback(0.0, message)
        return

    if ret.returncode != 0:
        message = "Building failed. Error:\r\n" + ret.stderr.decode('utf-8')
        send_feedback(0.0, message)
        return

    # Checking the existence of built program executable
    app_loc = os.path.join(build_dir, BUILT_EXECUTABLE_NAME)
    if not os.path.isfile(app_loc):
        message = "Building failed. Built program executable not found!"
        send_feedback(0.0, message)
        return

    # Finding all testcases applicable
    tests = [x for x in os.listdir(part_folder) if
             (os.path.isdir(os.path.join(part_folder, x)) and x.lower().startswith('testcase_'))]
    tests.sort()

    # Initial score. Score is reduced after each failed testcase.
    score = 1
    message = ""
    print("Running...")
    test_number = 0
    for test in tests:
        test_failed = False
        test_number += 1
        test_dir = os.path.join(part_folder, test)
        test_w_dir = os.path.join(test_dir, "working_directory")
        with open(os.path.join(test_dir, 'input_commandline.txt'), "r") as f:
            test_cl = f.read().strip()
        with open(os.path.join(test_dir, 'input_console.txt'), "r") as f:
            test_in = f.read().strip()
        with open(os.path.join(test_dir, 'expected_output_console.txt'), "r") as f:
            test_out = f.read().strip()
        # Running the program with the testcase
        try:
            ret = subprocess.run([app_loc, test_cl],
                                 cwd=test_w_dir,
                                 input=test_in,
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE,
                                 text=True,
                                 timeout=RUN_TIMEOUT)
        except Exception as e:
            message += "Test(" + str(test_number) + ") : Runtime failed.\r\n" + str(e) + "\r\n"
            test_failed = True

        if not test_failed:
            # Checking the stdout of the program

            if text_mismatch(test_out, ret.stdout):
                test_failed = True
                message += "Test(" + str(test_number) + ") : Console output mismatch.\r\n"
                if test_number == 1:
                    # Giving additional info on first testcase.
                    # First testcase's output should be open as a sample output expected.
                    message += diff_message(ret.stdout, test_out)
            # Checking additional files generated by the program
            out_file_check_folder = os.path.join(test_dir, "expected_output_files")
            out_files = [x for x in os.listdir(out_file_check_folder) if
                         os.path.isfile(os.path.join(out_file_check_folder, x))]
            for out_file in out_files:
                if out_file.startswith("Tip "):
                    continue
                if not os.path.isfile(os.path.join(test_w_dir, out_file)):
                    message += "Test(" + str(test_number) + ") : Output file missing: " + out_file + "\r\n"
                    test_failed = True
                else:
                    with open(os.path.join(out_file_check_folder, out_file), "r") as f:
                        test_out_expected = f.read()
                    with open(os.path.join(test_w_dir, out_file), "r") as f:
                        test_out_generated = f.read()
                    if text_mismatch(test_out_expected, test_out_generated):
                        message += "Test(" + str(test_number) + ") : Output file mismatch: " + out_file + "\r\n"
                        test_failed = True
                        if test_number == 1:
                            message += diff_message(test_out_generated, test_out_expected)
        # Immediately fail if the first testcase (demo testcase) fails.
        if test_failed and test_number == 1:
            score = 0
            break
        # Apply penalty if the testcase is failed
        if test_failed:
            score -= PENALTY
        # Stop testing if score reaches zero. Too many failed testcases.
        if score <= 0:
            score = 0
            break

    # Calculate correct fractional score if number of testcases is less than 1/PENALTY
    if 0 < score < 1 and PENALTY > 0 and test_number <= (1 / PENALTY):
        score = max(0.0, (test_number - (1 - score) / PENALTY) / test_number)
    if score > GOOD_SCORE:
        message += "Great job!\r\n"
    else:
        message += "Try again!\r\n"

    send_feedback(score, message)


if __name__ == '__main__':
    print("Version: 1.3")
    try:
        part_id = os.environ['partId']
    except KeyError as e:
        msg = "Please provide the coursera partId. (Coursera Admin Error)"
        send_feedback(0.0, msg)
    else:
        main(part_id)
